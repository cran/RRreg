<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Daniel W. Heck" />

<meta name="date" content="2016-01-12" />

<title>RRreg manual</title>

<script src="RRreg_files/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="RRreg_files/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<script src="RRreg_files/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="RRreg_files/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="RRreg_files/bootstrap-3.3.1/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="RRreg_files/highlight/textmate.css"
      type="text/css" />
<script src="RRreg_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>


<link rel="stylesheet" href="markdown10.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div id="header">
<h1 class="title">RRreg manual</h1>
<h4 class="author"><em>Daniel W. Heck</em></h4>
<h4 class="date"><em>2016-01-12</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#statistical-functions"><span class="toc-section-number">2</span> Statistical functions</a></li>
<li><a href="#testing-rr-vs.direct-questioning-dq"><span class="toc-section-number">3</span> Testing RR vs. direct questioning (DQ)</a></li>
<li><a href="#other-rr-models-using-one-group"><span class="toc-section-number">4</span> Other RR models using one group</a></li>
<li><a href="#two-group-models"><span class="toc-section-number">5</span> Two-group models</a></li>
</ul>
</div>

<p>Correlation and regression analysis for randomized response designs</p>
<p>Contact: <a href="mailto:dheck@mail.uni-mannheim.de">dheck@mail.uni-mannheim.de</a></p>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>The randomized response (RR) design was developed by Warner (1965) to allow for complete anonymity of the respondents in surveys and thus to reduce effects of social desirability. In general, some kind of random noise (e.g., throwing a pair of dices) is added to the true response. Whereas the prevalence of a senstive attribute (by convention termed <span class="math">\(\pi\)</span>) can still be estimated at the group level, an individual response does not disclose the true state of the respondent. Accordingly, RR data require adapted models and formulas for multivariate analysis, implemented in the package <code>RRreg</code>.</p>
<p>The main functions provide the following functionality and are explained in more detail in Section 2:</p>
<ul>
<li><a href="#RRuni">RRuni</a>: simple univariate analysis, i.e., prevalence estimates</li>
<li><a href="#RRcor">RRcor</a>: bivariate correlations including RR variables</li>
<li><a href="#RRlog">RRlog</a>: logistic regression with an RR variable as criterion</li>
<li><a href="#RRmixed">RRmixed</a>: logistic RR regression including random effects (nested or hierarchical data)</li>
<li><a href="#RRlin">RRlin</a>: linear regression with a continuous, non-RR criterion including RR variables as predictors</li>
</ul>
<p>Additionally, three functions can be used to generate data for robustness studies, power analysis, bootstrap estimates, and other testing purposes:</p>
<ul>
<li><a href="#RRgen">RRgen</a>: generates a single data frame including true states, RR responses, and group memberships</li>
<li><a href="#RRsimu">RRsimu</a>: Monte Carlo simulation to test <code>RRuni</code>,<code>RRcor</code>, <code>RRlog</code>, and <code>RRlin</code> either for one RR and one continuous non-RR variable or for two RR variables (only <code>RRcor</code>)</li>
<li><a href="#powerplot">powerplot</a>: Monte Carlo simulation to plot the power of the methods <code>RRuni</code>,<code>RRcor</code>, <code>RRlog</code>, or <code>RRlin</code> either for one RR and one continuous non-RR variable</li>
</ul>
<p>In the following, cocaine abuse is used as a running example to demonstrate the RR analysis with <code>RRreg</code>. The following RR designs are included in the package: <a href="#UQTknown">UQTknown</a>, <a href="#Mangat">Mangat</a>, <a href="#Kuk">Kuk</a>, <a href="#FR">FR</a>, <a href="#Crosswise">Crosswise</a>, <a href="#UQTunknown">UQTunknown</a>, <a href="#CDM">CDM</a>, <a href="#CDMsym">CDMsym</a>, <a href="#SLD">SLD</a></p>
<p> </p>
</div>
<div id="statistical-functions" class="section level1">
<h1><span class="header-section-number">2</span> Statistical functions</h1>
<p><a id="Warner"></a> <a id="RRuni"></a></p>
<div id="univariate-analysis" class="section level3">
<h3><span class="header-section-number">2.0.1</span> Univariate analysis</h3>
<p>The original RR design proposed by Warner in 1965 works as follows: With randomization probability <code>p</code>, participants are supposed to answer to the question ‘Have you ever used cocaine?’, and with counter-probability <code>1-p</code>, the question is reversed, i.e., ‘Have you never used cocaine?’. As a randomization device, dices or coin flips with known probabilities may be used. The model is depicted in the following figure:</p>
<p><img src="figures/Warner.jpg" alt="title" /></p>
<p><a id="RRgen"></a> First, let’s load the package and generate a single data frame using the function <code>RRgen</code>. We simulate data for 1000 participants, a proportion of 30% cocaine users (<code>pi.true=.3</code>; obviously, this rate is unrealistic, but it should suffice for the sake of example), and a randomization probability of <code>p=.2</code>:</p>
<pre class="r"><code>library(RRreg)</code></pre>
<pre><code>## Warning: replacing previous import &#39;lme4::sigma&#39; by &#39;stats::sigma&#39; when
## loading &#39;RRreg&#39;</code></pre>
<pre class="r"><code>data.W &lt;- RRgen(n=1000, pi.true=.3, model=&quot;Warner&quot;, p=.2, complyRates = c(1, 1), sysBias = c(0,0))
head(data.W)</code></pre>
<pre><code>##   true comply response
## 1    1      1        0
## 2    1      1        0
## 3    1      1        0
## 4    0      1        1
## 5    0      1        1
## 6    1      1        0</code></pre>
<p>In the function <code>RRgen</code>, the argument <code>complyRates</code> gives the proportions of participants who do adhere to the RR instructions for carriers and non-carriers of the sensitive attribute, respectively. The argument <code>sysBias</code> gives the probability of <em>yes</em> responses in case of non-compliance for carriers and non-carriers, respectively. If <code>sysBias=c(0,0)</code>, noncomplying individuals always respond with self-protective <em>no</em> responses (also known as SP-‘no’ responses). In comparison, <code>sysBias=c(0,0.5)</code> indicates that noncomplying non-carriers answer <em>yes</em> or <em>no</em> by chance. However, since we generated data assuming perfect compliance, this argument can be neglected. These options can be used to test how robust the results are against non-adherence.</p>
<p>Now that we have a data set, we can estimate the prevalence of cocaine users by means of <code>RRuni</code>:</p>
<pre class="r"><code>warner &lt;- RRuni(response=response, data=data.W, model=&quot;Warner&quot;, p=.2, MLest=T)
summary(warner)</code></pre>
<pre><code>## Warner Model with p = 0.2
## Sample size: 1000
## 
##    Estimate   StdErr      z  Pr(&gt;|z|)    
## pi 0.298333 0.025569 11.668 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The <code>response</code> variable containing 1 for <em>yes</em> and 0 for <em>no</em> responses can either be given as a vector or as a column name in the data set <code>data</code>. Moreover, the argument <code>model</code> specifies the RR design with its randomization probability given by <code>p</code> (see Sections 4 and 5 for details about other RR models) . If <code>MLest=FALSE</code> is used, the prevalence estimate is derived as an analytical least-squares estimator, which can assume values outside of the interval [0,1]. However, using <code>MLest=TRUE</code> (default), estimates of <code>pi</code> are restricted to the interval [0,1].</p>
<ul>
<li>Warner, S. L. (1965). Randomized response: A survey technique for eliminating evasive answer bias. <em>Journal of the American Statistical Association, 60</em>, 63-69.</li>
</ul>
<p> </p>
</div>
<div id="multivariate-analysis" class="section level3">
<h3><span class="header-section-number">2.0.2</span> Multivariate analysis</h3>
<p>First, we generate a continuous, non-RR variable. According to our simulation, respondents carrying the sensitive attribute (i.e., cocaine users) have higher scores on this covariate:</p>
<pre class="r"><code>data.W$cov[data.W$true==1] &lt;- rnorm(sum(data.W$true == 1),1)
data.W$cov[data.W$true==0] &lt;- rnorm(sum(data.W$true == 0))</code></pre>
<p><a id="RRcor"></a></p>
<p> </p>
<div id="rrcor" class="section level4">
<h4><span class="header-section-number">2.0.2.1</span> RRcor</h4>
<p>Now, we can estimate the bivariate (point-biserial) correlation between the dichotomous Warner RR variable and the continuous covariate:</p>
<pre class="r"><code>RRcor(x=data.W$response, y=data.W$cov, models=c(&quot;Warner&quot;, &quot;direct&quot;), p.list=list(.2), bs.n=0, bs.type = c(&quot;se.n&quot;, &quot;se.p&quot;, &quot;pval&quot;), nCPU=1)</code></pre>
<pre><code>## Randomized response variables:
##   Variable        RRmodel p   
## 1 data.W$response Warner   0.2
## 2 data.W$cov      direct      
## 
## Sample size N = 1000 
## 
## Estimated correlation matrix:
##                 data.W$response data.W$cov
## data.W$response        1.000000   0.347003
## data.W$cov             0.347003   1.000000</code></pre>
<p>The argument <code>models</code> defines which variables given by <code>x</code> and <code>y</code> are treated as RR variables. <code>x</code> and <code>y</code> can be vectors and/or data frames/matrices having one variable in each column (the order is then given as following: First, columns of <code>x</code> from left to right, and second, columns of <code>y</code> from left to right). The randomization probabilities <code>p.list</code> have to be in the same order as <code>models</code>. No values have to be specified for direct (nonRR) variables. To obtain bootstrapped standard errors, <code>bs.n</code> has to be set to a number of bootstrap replications larger than 0. Additionally, <code>bs.type</code> defines which kind of bootstrap should be performed (<code>&quot;se.n&quot;</code>, <code>&quot;se.p&quot;</code>: nonparametric/parametric for standard errors; <code>&quot;pval&quot;</code> parametric bootstrap assuming independence for p-values). For faster processing, <code>nCPU</code>can be increased to use parallel computation. In our example, we also know the true states of the participants in the data set and can check the results by:</p>
<pre class="r"><code>cor(x=data.W$true, y=data.W$cov)</code></pre>
<pre><code>## [1] 0.4094017</code></pre>
<ul>
<li>Fox, J. A., &amp; Tracy, P. E. (1984). Measuring associations with randomized response. <em>Social Science Research, 13</em>, 188-197.</li>
</ul>
<p> </p>
<p><a id="RRlog"></a></p>
</div>
<div id="rrlog" class="section level4">
<h4><span class="header-section-number">2.0.2.2</span> RRlog</h4>
<p>Alternatively, we can run a logistic regression to predict the probability of cocaine use. In the <code>formula</code> below, the Warner RR variable is defined as criterion on the left side, whereas the continuous covariate is used as predictor on the right. The interface is similar to that of the standard linear regression in R (i.e., <code>lm()</code>).</p>
<pre class="r"><code>log1 &lt;- RRlog(formula=response~cov, data=data.W, model=&quot;Warner&quot;, p=.2, LR.test=TRUE, fit.n = 1)
summary(log1)</code></pre>
<pre><code>## Call:
## RRlog.formula(formula = response ~ cov, data = data.W, model = &quot;Warner&quot;, 
##     p = 0.2, LR.test = TRUE, fit.n = 1)
## 
## RR Model:
## Warner with p =  0.2
## 
## Model fit:
##     n    logLik
##  1000 -641.7381
## 
##             Estimate   StdErr Wald test Pr(&gt;Chi2,df=1) deltaG2
## (Intercept) -1.39208  0.20618  45.58744        0.00000  93.000
## cov          0.90584  0.17154  27.88603        0.00000  43.669
##             Pr(&gt;deltaG2)    
## (Intercept)    &lt; 2.2e-16 ***
## cov            &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>To remove the intercept from the model, use <code>formula=response~cov - 1</code>. The argument <code>LR.test</code> determines whether the coefficients should be tested by means of a likelihood ratio test, that is, by removing one predictor at a time. Again, we can check the results by:</p>
<pre class="r"><code>glm(formula=true~cov, data=data.W, family=binomial(link = &quot;logit&quot;))</code></pre>
<pre><code>## 
## Call:  glm(formula = true ~ cov, family = binomial(link = &quot;logit&quot;), 
##     data = data.W)
## 
## Coefficients:
## (Intercept)          cov  
##     -1.2768       0.9971  
## 
## Degrees of Freedom: 999 Total (i.e. Null);  998 Residual
## Null Deviance:       1260 
## Residual Deviance: 1076  AIC: 1080</code></pre>
<ul>
<li>van den Hout, A., van der Heijden, P. G., &amp; Gilchrist, R. (2007). The logistic regression model with response variables subject to randomized response. <em>Computational Statistics &amp; Data Analysis, 51</em>, 6060-6069.</li>
</ul>
<p> </p>
<p><a id="RRmixed"></a></p>
</div>
<div id="rrmixed" class="section level4">
<h4><span class="header-section-number">2.0.2.3</span> RRmixed</h4>
<p>If the data are nested (e.g., students within schools), the logistic regression can be extended to include random effects. In R, the package <code>lme4</code> allows for flexible generalized linear mixed models (GLMMs) which include RR logistic regression as a special case. The function <code>RRmixed</code> uses the function <code>glmer</code>of <code>lme4</code> and an adjusted link function. However, at the moment this can only be used with one-group RR models that assume the same link function for all responses.</p>
<p>Some typical examples how to specify models fia the <code>formula</code> are:</p>
<ul>
<li>random effects: <code>rrt ~ covariate + (1 | cluster)</code></li>
<li>random slopes: <code>rrt ~ covariate + (0+covariate | cluster)</code></li>
<li>both: <code>rrt ~ covariate +(covariate | cluster)</code></li>
<li>level-2 predictors: <code>rrt ~ covariate + lev2pred + (1 | cluster)</code> (the predictor lev2pred must have constant values within clusters)</li>
</ul>
<p>The function <code>RRmixed</code> is used as follows:</p>
<pre class="r"><code># make random cluster:
data.W$cluster &lt;- c(&quot;a&quot;, &quot;b&quot;)
mixmod &lt;- RRmixed(response ~ cov + (1 | cluster), data=data.W, model = &quot;Warner&quot;, p = .2)
mixmod</code></pre>
<pre><code>## Generalized linear mixed model fit by maximum likelihood (Laplace
##   Approximation) [glmerMod]
##  Family: binomial  ( logRR(0.8,0.2) )
## Formula: response ~ cov + (1 | cluster)
##    Data: data
##       AIC       BIC    logLik  deviance  df.resid 
## 1287.7193 1302.4426 -640.8597 1281.7193       997 
## Random effects:
##  Groups  Name        Std.Dev.
##  cluster (Intercept) 0.2709  
## Number of obs: 1000, groups:  cluster, 2
## Fixed Effects:
## (Intercept)          cov  
##     -1.3843       0.9018</code></pre>
<ul>
<li>van den Hout, A., van der Heijden, P. G., &amp; Gilchrist, R. (2007). The Logistic Regression Model with Response Variables Subject to Randomized Response. <em>Computational Statistics &amp; Data Analysis</em>, 51, 6060–6069.</li>
</ul>
<p> </p>
<p><a id="RRlin"></a></p>
</div>
<div id="rrlin" class="section level4">
<h4><span class="header-section-number">2.0.2.4</span> RRlin</h4>
<p>Third, we can use the Warner RR variable as predictor in a linear regression:</p>
<pre class="r"><code>lin1 &lt;- RRlin(formula=cov~response, data=data.W, models=&quot;Warner&quot;, p.list=.2, bs.n=0, fit.n=1)
summary(lin1)</code></pre>
<pre><code>## Call:
## RRlin(formula = cov ~ response, data = data.W, models = &quot;Warner&quot;, 
##     p.list = 0.2, bs.n = 0, fit.n = 1)
## 
## Randomized response variables:
##   Variable Model  p  
## 1 response Warner 0.2
## 
## Coefficients (beta):
##             Estimate  StdErr Wald test Pr(&gt;Chi2,df=1)    
## (Intercept)  0.12304 0.04791    6.5971        0.01021 *  
## response     0.85246 0.12357   47.5899        &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error (sigma): 0.989; N=1000</code></pre>
<p>As in <code>RRcor</code>, bootstrapped standard errors can be obtained by setting <code>bs.n</code> to the number of bootstrap replications. The order of the RR models is defined by <code>models</code> and <code>p.list</code>. For instance, given three RR variables <code>rr1</code>, <code>rr2</code>, and <code>rr3</code> and two non-RR/direct variables <code>x1</code> and <code>x2</code>, the model could be specified by <code>formula = y ~ rr1 + x1 + rr2 + rr3 + x2</code> and <code>models=c('Warner', 'direct', 'Warner', 'Warner', 'direct')</code>. Note that the predictors in <code>formula</code> can either be vectors or column names of variables in the data frame <code>data</code>.</p>
<p>As a special case, if the number of predictors used in the formula interface is larger than the number of RR variables specified in <code>models</code>, the remaining predictors are treated as directly measured, non-RR variables:</p>
<pre class="r"><code>data.W$pred &lt;- rnorm(1000)
lin2 &lt;- RRlin(formula=cov~response + pred, data=data.W, models=&quot;Warner&quot;, p.list=list(.2), bs.n=0, fit.n=1)
summary(lin2)</code></pre>
<pre><code>## Call:
## RRlin(formula = cov ~ response + pred, data = data.W, models = &quot;Warner&quot;, 
##     p.list = list(0.2), bs.n = 0, fit.n = 1)
## 
## Randomized response variables:
##   Variable Model  p  
## 1 response Warner 0.2
## 
## Coefficients (beta):
##             Estimate  StdErr Wald test Pr(&gt;Chi2,df=1)    
## (Intercept)  0.12377 0.04797    6.6571        0.00988 ** 
## response     0.84936 0.12397   46.9396        &lt; 2e-16 ***
## pred         0.01378 0.03265    0.1781        0.67304    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error (sigma): 0.989; N=1000</code></pre>
<p>To check the results of the simulation, run:</p>
<pre class="r"><code>lm(cov~true + pred, data=data.W)</code></pre>
<pre><code>## 
## Call:
## lm(formula = cov ~ true + pred, data = data.W)
## 
## Coefficients:
## (Intercept)         true         pred  
##     0.07313      0.92824      0.01609</code></pre>
<p>It is also possible to include several RR variables as predictors if the randomization devices used are stochastically independent:</p>
<pre class="r"><code>data.W2 &lt;- RRgen(n=1000, pi.true=.45, model=&quot;Warner&quot;, p=.35)
data.W$cov &lt;-2*data.W$true - 3*data.W2$true+ rnorm(1000,1,5)
data.W$response2 &lt;- data.W2$response
lin3 &lt;- RRlin(cov ~ response + response2, data=data.W, models=c(&quot;Warner&quot;, &quot;Warner&quot;), p.list=list(.2, .35), fit.n=1)
summary(lin3)</code></pre>
<pre><code>## Call:
## RRlin(formula = cov ~ response + response2, data = data.W, models = c(&quot;Warner&quot;, 
##     &quot;Warner&quot;), p.list = list(0.2, 0.35), fit.n = 1)
## 
## Randomized response variables:
##   Variable  Model  p   
## 1 response  Warner 0.2 
## 2 response2 Warner 0.35
## 
## Coefficients (beta):
##             Estimate   StdErr Wald test Pr(&gt;Chi2,df=1)    
## (Intercept)  0.71400  0.52929    1.8197        0.17734    
## response     3.63097  1.00296   13.1061        0.00029 ***
## response2   -3.24558  1.30242    6.2099        0.01270 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error (sigma): 5.223; N=1000</code></pre>
<p>Besides the regression output, the function <code>summary</code> also provides ‘Prevalence estimates for combinations of RR responses’. In our example using two Warner variables, the combination 0:0 indicates the sub-group having neither of both sensitive attributes and shows the corresponding prevalence estimate. Similarly, the combination 0:1 indicates the sub-group having only the second sensitive attribute and so on. Note that the last combination 1:1 is not provided and can be calculated by summing up all other prevalence estimates and substracting this sum from 1.</p>
<p>To include many RR variables as predictors, very large sample sizes are required for reliable estimation. In such a case, it might be necessary to adjust the optimization parameters <code>maxit</code> (maximum number of iterations) and <code>pibeta</code> (relative ratio of proability scale for <code>pi</code> to regression coefficients <code>beta</code>; e.g., choose a smaller value for larger absolute beta values).</p>
<ul>
<li>van den Hout, A., &amp; Kooiman, P. (2006). Estimating the linear regression model with categorical covariates subject to randomized response. <em>Computational Statistics &amp; Data Analysis, 50</em>, 3311-3323.</li>
</ul>
<p> </p>
</div>
</div>
</div>
<div id="testing-rr-vs.direct-questioning-dq" class="section level1">
<h1><span class="header-section-number">3</span> Testing RR vs. direct questioning (DQ)</h1>
<p>The method <code>RRlog</code> can be used to test whether an RR design leads to higher prevalence estimates than direct questioning (DQ). For one-groups designs (such as the Warner model), define a vector with indices 0 for all participants who were questioned by DQ and indices 1 for participants questioned by the RR design and include this dummy variable as predictor. For two-group designs (see below), define a dummy variable contrasting DQ and RR as before, and define a vector with indices 0 for participants questioned by DQ and indices 1 and 2 denoting the group of the RR design.</p>
<p>If the regression coefficient of the dummy predictor is significant, this indicates different prevalence rates between RR and DQ.</p>
<p>Furthermore, interactions between question format (RR vs. DQ) and other predictors can be tested. For instance, one might want to know whether the regression coefficient of a predictor (e.g., age) differs between question formats (e.g., whether the RR format serves as a more valid criterion). Interactions are included by <code>formula= RR ~ format + age + format:age</code>.</p>
<p>An example is:</p>
<pre class="r"><code># generate data with different prevalence rates for RR and DQ
RR &lt;- RRgen(n=500, pi=.4, model=&quot;Warner&quot;, p=.35)
DQ &lt;- rbinom(500, 1, .2)
response &lt;- c(RR$response, DQ)
# dummy variable for RR vs. DQ
group &lt;- rep(1:0, each=500)
# include interaction of question format and age (here, the rescaled z-variable z.age)
z.age &lt;- c(rnorm(500, mean=RR$true*2,sd=3), rnorm(500, mean=0,sd=3))
# fit full model (i.e., test difference in prevalence estimates and interaction)
fit &lt;- RRlog(response ~ group * z.age, model=&quot;Warner&quot;, p=.35, group=group, LR.test=TRUE, fit.n = 1) </code></pre>
<pre><code>## Warning: The group vector contains 2 categories, which are interpreted as
## follows: 0=direct question format ; 1=randomized response format</code></pre>
<pre class="r"><code>summary(fit)</code></pre>
<pre><code>## Call:
## RRlog.formula(formula = response ~ group * z.age, model = &quot;Warner&quot;, 
##     p = 0.35, group = group, LR.test = TRUE, fit.n = 1)
## 
## RR Model:
## Warner with p =  0.35 (n=500) combined with DQ (n=500)
## 
## Model fit:
##     n    logLik
##  1000 -593.6773
## 
##              Estimate    StdErr Wald test Pr(&gt;Chi2,df=1)  deltaG2
## (Intercept)  -1.40071   0.11257 154.81825        0.00000 195.1665
## group         0.97983   0.34288   8.16613        0.00427   5.8943
## z.age        -0.04509   0.03613   1.55766        0.21201   1.5594
## group:z.age   0.09720   0.10664   0.83093        0.36200   0.8732
##             Pr(&gt;deltaG2)    
## (Intercept)      &lt; 2e-16 ***
## group            0.01519 *  
## z.age            0.21176    
## group:z.age      0.35006    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># get prevalence estimate for RR and DQ
logit1 &lt;- coef(fit) %*% c(1, 1, mean(z.age), mean(z.age))
cat(exp(logit1) / (1+ exp(logit1)))</code></pre>
<pre><code>## 0.4019471</code></pre>
<pre class="r"><code>logit2 &lt;- coef(fit) %*% c(1, 0, mean(z.age), 0)
cat(exp(logit2) / (1+ exp(logit2)))</code></pre>
<pre><code>## 0.1944963</code></pre>
<p> </p>
</div>
<div id="other-rr-models-using-one-group" class="section level1">
<h1><span class="header-section-number">4</span> Other RR models using one group</h1>
<p>In the following, several other available RR models are listed, which can be used throughout the package functions. For each model, the randomization probability <code>p</code> must be given as defined below.</p>
<p> </p>
<p><a id="UQTknown"></a></p>
<div id="unrelated-question-techique-with-known-prevalance-uqtknown" class="section level4">
<h4><span class="header-section-number">4.0.0.1</span> Unrelated question techique with known prevalance (UQTknown)</h4>
<p><code>model = 'UQTknown'</code></p>
<p>In this RR design, participants either respond to the sensitive question or to a second irrelevant question. Importantly, the interviewer is unaware which question was answered. The randomization probability <code>p[1]</code> determines the proportion of participants that is directed to answer the sensitive question, whereas the remaining participants answer the irrelevant question. In the UQTknown design, the prevalence rate of <em>yes</em> responses for this irrelevant question must be known beforehand (e.g., “Is your birthday in April?”, <code>p[2]=1/12</code>) and provided together with the randomization probability by the vector <code>p=c(p[1], p[2])</code> (see <a href="#UQTunknown">UQTunknown</a> if the prevalence is unknown).</p>
<p><img src="figures/UQTknown.jpg" alt="title" /></p>
<ul>
<li>Scheers, N. J. (1992). A review of randomized response techniques. <em>Measurement and Evaluation in Counseling and Development, 25</em>, 27-41.</li>
</ul>
<p> </p>
<p><a id="Mangat"></a></p>
</div>
<div id="mangat" class="section level4">
<h4><span class="header-section-number">4.0.0.2</span> Mangat</h4>
<p><code>model = 'Mangat'</code></p>
<p>In Mangat’s model, carriers of the critical attribute are always provided with the sensitive statement. In contrast, non-carriers of the critical attribute are to respond to the sensitive statement with probability <code>p</code> and to its negation otherwise.</p>
<p><img src="figures/Mangat.jpg" alt="title" /></p>
<ul>
<li>Mangat, N. (1994). An improved randomized-response strategy. <em>Journal of the Royal Statistical Society, Series B, 56</em>, 93-95.</li>
</ul>
<p> </p>
<p><a id="Kuk"></a></p>
</div>
<div id="kuk" class="section level4">
<h4><span class="header-section-number">4.0.0.3</span> Kuk</h4>
<p><code>model = 'Kuk'</code></p>
<p>Kuk’s method uses two decks of playing cards to ensure anonymity of the respondents. Whereas carriers of the sensitive attribute are told to report the color of a card drawn from the <em>first</em> deck, non-carriers should report the color of a card from the <em>second</em> deck. Importantly, the interviewer does not know, from which deck a card was drawn.</p>
<p>Each deck contains red and black cards, coded with 1 and 0, respectively. However, the proportion of red cards differs in the two decks, defined by the vector <code>p=c(p[1], p[2])</code> (i.e., proportion of red cards for carriers and non-carriers of the sensitive attribute, respectively).</p>
<p>Note that the procedure can be applied repeatedly to obtain more reliable estimates (with replacement of the drawn cards). For instance, with 5 repetitions, the observed RR variable can assume values from 0 to 5, i.e., the reported number of red cards. The functions <code>RRgen</code> (data generation), <code>RRuni</code> (univariate analysis), and <code>RRlin</code> (linear regression with RR predictors) can accomodate this extended design, using the additional argument <code>Kukrep</code>. However, at the moment, this option is not available in <code>RRcor</code> and <code>RRlog</code>.</p>
<p><img src="figures/Kuk.jpg" alt="title" /></p>
<ul>
<li>Kuk, A. Y. (1990). Asking sensitive questions indirectly. <em>Biometrika, 77</em>, 436-438.</li>
</ul>
<p> </p>
<p><a id="FR"></a></p>
</div>
<div id="forced-response-fr" class="section level4">
<h4><span class="header-section-number">4.0.0.4</span> Forced response (FR)</h4>
<p><code>model = 'FR'</code></p>
<p>In the forced response (FR) model (also known as directed-answers model), a known proportion of the participants is prompted to respond <em>yes</em>, whereas another proportion is prompted to respond <em>no</em>, independent of their true status. Only the remaining participants answer truthfully. The randomization probability <code>p</code> is now a vector, containing two values, i.e., being prompted to respond <em>no</em> and <em>yes</em>, respectively. The model is shown in the following figure:</p>
<p><img src="figures/FR.jpg" alt="title" /></p>
<p>The FR model can easily be extended to account for more than two response categories. For instance, responses can be given on a 5-point Likert scale from 0 to 4. For these categories, the randomization probabilities, determining the proportion of forced responses, are provided in a vector <code>p=c(p[1], p[2],...,p[5])</code>. The sum of these probabilities must be smaller than one. This polytomous RR model can be used with the functions <code>RRgen</code>, <code>RRuni</code>, <code>RRcor</code>, and <code>RRlin</code> (the logistic RR regression <code>RRlog</code> requires a dichotomous response format).</p>
<p>The following code snippets illustrate, how the FR method is used with multiple response categories:</p>
<ul>
<li><code>RRgen(n=1000, pi.true=c(.3,.1,.4,.2), model=&quot;FR&quot;, p=c(.1,.1,.2,.05))</code></li>
<li><code>RRlin(criterion~response, data=dat, models=&quot;FR&quot;,p.list=list(c(.1,.1,.2,.05)), fit.n=1)</code></li>
</ul>
<p>For data generation of a polytomous FR model using <code>RRgen</code>, the arguments <code>complyRates</code> and <code>sysBias</code> have the following definition:</p>
<ul>
<li><code>complyRates=c(c0, c1, ...)</code> gives the probability of complying to the RR instructions separately for all possible true states</li>
<li><code>sysBias = c(s1, s2, ...)</code> defines the multinomial probability distribution which is used in case of noncompliance (the values have to sum up to 1).</li>
</ul>
<p>For instance, having the categories <code>0,1,2,3,4</code> and <code>complyRates=c(1,1,1,.8,.5), sysBias=c(.5,.3,.2,0,0)</code> would simulate the scenario that participants with true states 3 and 4 would comply less and instead prefer responses 0, 1, or 2.</p>
<ul>
<li>Greenberg, B. G., Abul-Ela, A.-L. A., Simmons, W. R., &amp; Horvitz, D. G. (1969). The Unrelated Question Randomized Response Model: Theoretical Framework. <em>Journal of the American Statistical Association, 64</em>, 520-539.</li>
</ul>
<p> </p>
<p><a id="Crosswise"></a></p>
</div>
<div id="crosswise-model" class="section level4">
<h4><span class="header-section-number">4.0.0.5</span> Crosswise model</h4>
<p><code>model = 'Crosswise'</code></p>
<p>Concerning the model equations, the Crosswise model is technically identical to the Warner model. However, instead of answering to the sensitive question directly, respondents are instructed to respond to the sensitive and an irrelevant question simultaneously, according to the following scheme:</p>
<ul>
<li>If your answer is <em>yes</em> to both questions or <em>no</em> to both questions, respond with <em>yes</em> (coded as 1)</li>
<li>If your answer is <em>yes</em> to one and <em>no</em> to the other question, respond with <em>no</em> (coded as 0)</li>
</ul>
<p><img src="figures/Crosswise.jpg" alt="title" /></p>
<p>For the irrelevant question, the prevalence of <em>yes</em> responses has to be known beforehand and is specified in RRreg by <code>p</code> (e.g., for the irrelevant question ‘Is Your birthday in March or April?’, <code>p = 2/12</code>).</p>
<ul>
<li>Yu, J.-W., Tian, G.-L., &amp; Tang, M.-L. (2008). Two new models for survey sampling with sensitive characteristic: Design and analysis. <em>Metrika, 67</em>, 251-263.</li>
</ul>
<p> </p>
<p><a id="custom"></a></p>
</div>
<div id="rr-as-misclassification" class="section level4">
<h4><span class="header-section-number">4.0.0.6</span> RR as Misclassification</h4>
<p><code>model = 'custom'</code></p>
<p>RR designs can be understood as a misclassification mechanisms: The true latent states/responses are perturbed randomly according to a known randomization scheme. This randomization scheme can be described in form of a matrix <span class="math">\(PW\)</span>, where each entry <span class="math">\(PW_{ji}\)</span> gives the probability to give a response <span class="math">\(j\)</span> if the true state is <span class="math">\(i\)</span>.</p>
<p>The package <code>RRreg</code> contains the function <code>getPW</code> to obtain this misclassification matrix for the implemented designs. The forced response design with proabilities <code>P=c(.1,.2)</code>, for instance, can be described by:</p>
<pre class="r"><code>getPW(model = &quot;FR&quot;, p = c(.1, .1))</code></pre>
<pre><code>##     0   1
## 0 0.9 0.1
## 1 0.1 0.9</code></pre>
<p>To specify a custom misclassification matrix, the arguments <code>model = &quot;custom&quot;</code> and a randomization matrix <code>p=matrix(p00, p10, p01, p11), ncol=2, nrow=2)</code> are required. The approach generalizes to categorical, non-binary data by specifying an <span class="math">\(m \times M\)</span> matrix. Note that for two-group designs, the matrix <span class="math">\(PW\)</span> depends on the groupd and on a second parameter, which needs to be estimated from the data (e.g., the unknown prevalence in <code>&quot;UQTunknown&quot;</code>).</p>
<ul>
<li>van den Hout, A., &amp; Kooiman, P. (2006). Estimating the Linear Regression Model with Categorical Covariates Subject to Randomized Response. <em>Computational Statistics &amp; Data Analysis</em>, 50(11), 3311–3323.</li>
</ul>
<p> </p>
<p><a id="two-group"></a></p>
</div>
</div>
<div id="two-group-models" class="section level1">
<h1><span class="header-section-number">5</span> Two-group models</h1>
<p>For several reasons, RR designs were proposed that require two independent random samples (groups). Historically, the second group was used to estimate the prevalence of the irrelevant question in the UQT. Alternatively, two groups allow for a second parameter, quantifying cheating or compliance with the RR procedure.</p>
<p>For these two-group models, the functions <code>RRuni</code>, <code>RRcor</code>, <code>RRlog</code>, and <code>RRlin</code> additionally require a vector <code>group</code> with values in 1 and 2, indicating the group membership of each respondent. If more than one RR variable is in the model, <code>group</code> is specified by a matrix containing the corresponding group vectors (one in each column) in the same order as the RR variables appear in the model. Moreover, the randomization probability <code>p</code> often specifies different values for the two groups. Code examples are given in <a href="#two-group-code-example">Section 5.5</a>.</p>
<p>Note that in the functions <code>RRcor</code> and <code>RRlin</code>, the second parameter of these two-group models is estimated first and then treated as a fixed constant in further computations. For the maximum likelihood estimation in <code>RRlin</code>, the second parameter should ideally be included as an additional, free parameter to provide unbiased standard errors (this is the case for the function <code>RRlog</code>). However, simulations show that the results are still adequate. <code>RRsimu</code> can be used to run such a simulations yourself and get bootstrapped standard errors.</p>
<p> </p>
<p><a id="UQTunknown"></a></p>
<div id="unrelated-question-techique-with-unknown-prevalance-uqtunknown" class="section level4">
<h4><span class="header-section-number">5.0.0.1</span> Unrelated question techique with unknown prevalance (UQTunknown)</h4>
<p><code>model = 'UQTunknown'</code></p>
<p>In this extension of the <a href="#UQTknown">UQTknown</a> RR design, the prevalence of the second, irrelevant question is unknown beforehand and estimated from the data. Note that this second question has to be stochastically independent of the sensitive attribute.</p>
<p>The randomization probability <code>p</code> is defined as</p>
<ul>
<li><code>p[1]</code> - probability to respond to the sensitive question in group 1</li>
<li><code>p[2]</code> - probability to respond to the sensitive question in group 2</li>
</ul>
<p>The randomization probabilities must differ across groups to render the model identifiable (i.e., <code>p[1]!=p[2]</code>). When generating data by means of <code>RRgen</code>, the prevalence rates of <em>yes</em> responses can be specified by <code>pi=c(pi.sensitive, pi.irrelevant)</code>. If only a single value is provided, the prevalence rate for the irrelevant question is randomly drawn from a uniform distribution.</p>
<p>Note that Moor’s variant of the UQT with unknown prevalence can be used by setting <code>p[2]=0</code>. Thereby, the second group is only used to estimate the prevalence of responding <em>yes</em> to the irrelevant question.</p>
<p><img src="figures/UQTunknown.jpg" alt="title" /></p>
<ul>
<li><p>Greenberg, B. G., Abul-Ela, A.-L. A., Simmons, W. R., &amp; Horvitz, D. G. (1969). The Unrelated Question Randomized Response Model: Theoretical Framework. <em>Journal of the American Statistical Association, 64</em>, 520-539.</p></li>
<li><p>Moors, J. J. A. (1971). Optimization of the Unrelated Question Randomized Response Model. <em>Journal of the American Statistical Association, 66</em>, 627-629.</p></li>
</ul>
<p> </p>
<p><a id="CDM"></a></p>
</div>
<div id="cheating-detection-model-cdm" class="section level4">
<h4><span class="header-section-number">5.0.0.2</span> Cheating detection model (CDM)</h4>
<p><code>model = 'CDM'</code></p>
<p>The CDM is based on the forced-response design and prompts a proportion <code>p</code> of participants to respond <em>yes</em> regardless of their true state. In contrast to the FR design, the cheating detection model (CDM) divides the population into three distinct groups: Compliant carriers of the sensitive attribute (<code>pi</code>), compliant noncarriers (<code>beta</code>), and cheating respondents who always respond <em>no</em> (<code>gamma</code>). This last group of cheaters is not further divided into carriers and noncarriers of the sensitive attribute. To estimate the two parameters <code>pi</code> and <code>gamma</code>, the sample is randomly divided into two parts using different randomization probabilities defined as:</p>
<ul>
<li><code>p[1]</code> - probability to be prompted to say <em>yes</em> in group 1</li>
<li><code>p[2]</code> - probability to be prompted to say <em>yes</em> in group 2</li>
</ul>
<p>The randomization probabilities must differ across groups to render the model identifiable (i.e., <code>p[1]!=p[2]</code>).</p>
<p>Because of the assumption of three distinct groups, the CDM is not available in the functions <code>RRcor</code> and <code>RRlin</code>. However, the function <code>RRlog</code> performs a logistic regression to predict the probability of being in the first group (i.e., having the sensitive attribute and complying with the RR procedure). Note that conclusions are restricted to this group, only.</p>
<p><img src="figures/CDM.jpg" alt="title" /></p>
<ul>
<li>Clark, S. J., &amp; Desharnais, R. A. (1998). Honest answers to embarrassing questions: Detecting cheating in the randomized response model. <em>Psychological Methods, 3</em>, 160-168.</li>
</ul>
<p> </p>
<p><a id="CDMsym"></a></p>
</div>
<div id="symmetric-cdm-cdmsym" class="section level4">
<h4><span class="header-section-number">5.0.0.3</span> Symmetric CDM (CDMsym)</h4>
<p><code>model = 'CDMsym'</code></p>
<p>In contrast to the standard cheating detection model (CDM) discussed in Section 5.2, in the <em>symmetric</em> CDM (CDMsym), some respondents are also prompted to respond <em>no</em> with a given probability, not only <em>yes</em>. Thereby, anonymity and compliance can be increased (Ostapczuk &amp; al., 2009), because participants directly see that both, <em>yes</em> and <em>no</em> responses are uninformative in respect to the sensitive attribute. Similarly as with the CDM, using CDMsym in <code>RRlog</code> predicts the joint probability of having the sensitive attribute and complying with the RR procedure. <code>CDMsym</code> cannot be used in the functions <code>RRcor</code>and <code>RRlin</code>.</p>
<p>The randomization probability <code>p</code> is a vector with 4 values:</p>
<ul>
<li><code>p[1]</code> - probability to be prompted to say <em>yes</em> in group 1</li>
<li><code>p[2]</code> - probability to be prompted to say <em>no</em> in group 1</li>
<li><code>p[3]</code> - probability to be prompted to say <em>yes</em> in group 2</li>
<li><code>p[4]</code> - probability to be prompted to say <em>no</em> in group 2</li>
</ul>
<p>The randomization probabilities must meet these restrictions:</p>
<ul>
<li>different probabilities across groups (<code>p[1]!=p[3]</code>and <code>p[2]!=p[4]</code>)</li>
<li>within each group, the sum of both probabilities is below one (<code>p[1]+p[2]&lt;1</code> and <code>p[3]+p[4]&lt;1</code>)</li>
</ul>
<p><img src="figures/CDMsym.jpg" alt="title" /></p>
<ul>
<li>Ostapczuk, M., Moshagen, M., Zhao, Z., &amp; Musch, J. (2009). Assessing sensitive attributes using the randomized response technique: evidence for the importance of response symmetry. <em>Journal of Educational and Behavioral Statistics, 34</em>, 267-287.</li>
</ul>
<p> </p>
<p><a id="SLD"></a></p>
</div>
<div id="stochastic-lie-detector-sld" class="section level4">
<h4><span class="header-section-number">5.0.0.4</span> Stochastic lie detector (SLD)</h4>
<p><code>model = 'SLD'</code></p>
<p>The stochastic lie detector (SLD) is based on Mangat’s model (Section 4.2) and adds a second parameter <code>t</code>, which gives the probability of honest responding within the group carrying the sensitive attribute. Note that in contrast to the CDM, the probability of having the sensitive attribute <code>pi</code> is corrected for cheating.</p>
<p>The randomization probability <code>p</code> is a vector with 2 values:</p>
<ul>
<li><code>p[1]</code> - probability for noncarriers to reply with <em>no</em> in group 1</li>
<li><code>p[2]</code> - probability for noncarriers to reply with <em>no</em> in group 2</li>
</ul>
<p>The randomization probabilities must differ across groups to render the model identifiable (i.e., <code>p[1]!=p[2]</code>).</p>
<p><img src="figures/SLD.jpg" alt="title" /></p>
<ul>
<li>Moshagen, M., Musch, J., &amp; Erdfelder, E. (2012). A stochastic lie detector. <em>Behavior Research Methods, 44</em>, 222-231.</li>
</ul>
<p> </p>
<p><a id="two-group-code-example"></a></p>
</div>
<div id="code-examples-for-two-group-models" class="section level4">
<h4><span class="header-section-number">5.0.0.5</span> Code examples for two-group models</h4>
<pre class="r"><code>### generate 2 two-group RR variables and a continuous covariate
RR1 &lt;- RRgen(1000, pi=.4, model=&quot;SLD&quot;, p=c(.2,.8), complyRates=c(.8,1))
RR2 &lt;- RRgen(1000, pi=.6, model=&quot;SLD&quot;, p=c(.3 ,.7), complyRates=c(.9,1))
cov &lt;- RR1$true + RR2$true + rnorm(1000, 0, 3)

### logistic regression (dependent RR variable)
logmod &lt;- RRlog(RR1$response ~ cov, model=&quot;SLD&quot;, p=c(.2,.8), group=RR1$group, fit.n = 1)
summary(logmod)</code></pre>
<pre><code>## Call:
## RRlog.formula(formula = RR1$response ~ cov, model = &quot;SLD&quot;, p = c(0.2, 
##     0.8), group = RR1$group, fit.n = 1)
## 
## RR Model:
## SLD with p =  0.2,0.8
## 
## Model fit:
##     n    logLik
##  1000 -598.6878
## 
##             Estimate   StdErr Wald test Pr(&gt;Chi2,df=1) deltaG2
## (Intercept) -0.39846  0.20205   3.88902        0.04860  3.9694
## cov          0.09277  0.05600   2.74432        0.09760  2.9852
## t            0.77111  0.04027  32.31412        0.00000 17.8909
##             Pr(&gt;deltaG2)    
## (Intercept)      0.04633 *  
## cov              0.08403 .  
## t                  2e-05 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Note that the parameter t is tested against the null hypothesis 
##         that all participants answered truthfully (i.e., H0: t=1).</code></pre>
<pre class="r"><code>### group matrix for RRlin and RRcor: use multiple group vectors in one matrix
group &lt;- cbind(RR1$group, RR2$group)

# bivariate correlation between 2 two-group variables and a continuous covariate
# note that only the most informative subsets of the data are used (see ?RRcor)
responses &lt;- cbind(RR1$response, RR2$response, cov)
colnames(responses) &lt;- c(&quot;RR1&quot;, &quot;RR2&quot;, &quot;cov&quot;)
RRcor( responses, models=c(&quot;SLD&quot;,&quot;SLD&quot;,&quot;direct&quot;), p.list=list(c(.2,.8), c(.3, .7)), group=group)</code></pre>
<pre><code>## Randomized response variables:
##   Variable RRmodel p       
## 1 RR1      SLD      0.2 0.8
## 2 RR2      SLD      0.3 0.7
## 3 cov      direct          
## 
## Sample size N = 1000 
## 
## Estimated correlation matrix:
##          RR1      RR2      cov
## RR1 1.000000       NA 0.133437
## RR2       NA 1.000000 0.277691
## cov 0.133437 0.277691 1.000000</code></pre>
<pre class="r"><code># linear model with 2 RR predictors
linmod &lt;- RRlin(cov ~ RR1$response+RR2$response, models=c(&quot;SLD&quot;,&quot;SLD&quot;), p.list=list(c(.2,.8), c(.3, .7)), group=group, fit.n=1)
summary(linmod)</code></pre>
<pre><code>## Call:
## RRlin(formula = cov ~ RR1$response + RR2$response, models = c(&quot;SLD&quot;, 
##     &quot;SLD&quot;), p.list = list(c(0.2, 0.8), c(0.3, 0.7)), group = group, 
##     fit.n = 1)
## 
## Randomized response variables:
##   Variable     Model p          
## 1 RR1$response SLD   c(0.2, 0.8)
## 2 RR2$response SLD   c(0.3, 0.7)
## 
## Coefficients (beta):
##              Estimate   StdErr Wald test Pr(&gt;Chi2,df=1)    
## (Intercept)  -0.65542  0.45324    2.0912        0.14815    
## RR1$response  1.05320  0.51970    4.1070        0.04271 *  
## RR2$response  1.84126  0.48703   14.2930        0.00016 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error (sigma): 2.878; N=1000</code></pre>
</div>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
